
# Analisis Desempeño

### Grafico
![Desempeño Entrega 6](https://user-images.githubusercontent.com/43649125/90345901-a2861f80-dff2-11ea-94fc-07226e50ea0d.png)

* Podemos observar que el metodo de solucion Ainv_X_B es el mas lento. Esto era de esperarse, ya que este metodo se realiza en 2 pasos. En primer lugar se invierte la matriz A y luego en otra variable se defina la multiplicacion entre A y B.
El resto de los metodos son de una sola ejecucion. Podemos ver que a mediad que N sube de valor tanto np.solve como scipy.solve se comportan de manera similar. Dado que estos solver son considerados "basicos" dentro de las funcionalidades que nos entregan nunmpy y scipy, no es extraño observar cierta similitud. Sin embargo y como se demostro en las entregas anteriores, scipy tiene un mejor desempeño comparado con numpy (en este grafico se puede observar claramente cuando N es pequeño).
Lo interesante surge de los 3 solvers restantes. Scipy.solve Symmetric tiene la particularidad que define una de las matrices a multiplicar como simetrica, es decir que su matriz triangular inferior y superior son iguales. La manera en la que trabaja es que solo toma la diagonal y la matriz triangular superior para realizar la multiplicacion y despues replica los resultados en la matriz triangular inferior, esto evidentemente y como se aprecia en el grafico la vuelve una alternativa mas rapida que las mencionadas anteriormente. Cabe destacar que si uno no posee una matriz simetrica, la multiplicacion se podra realizar de igual manera,pero por que asumira sumetria y trabajara como se menciono hace un instante, lo que implica que el resultado no sera el real ya que no estara considerando los valores reales de la matriz triangular inferior.
El solver scipy.solve possitive (pos) asume que la matriz indicada sera simetrica y positiva. De esta manera que se concentrara solo en los operadores positivos. Dado que en este caso particular nuestra matriz laplaciana tiene -1 a cada lado de la diagonal, estos valores no se consideran en el calculo y aumenta la eficiencia ensu calculo (en parte por que los componentes restantes de la matriz son puros 0 y 2). Para el caso del soler scipy.solve possitive overwrite hay que entender cual es la funcionalidad del comando overwrite.
Cuando una operacion de nuestro nivel se lleva a cabo en python, generealmente se trabaja con una funcion C-Fortran. Esta es una interfaz que relaciona las variables y las llamadas en subrutinas, ve la compatibilidad de los datos trabajados, el orden de las variables y la memoria utilizada, entre otros. Como interfaz de preferencia, su funcionalidad puede alterar los datos trabajados ya que su uso guarda archivos de memorias a medida que se ejecuta. Al utilizar el comando overwrite_a=True se esta creando un argumento opcional con valor por defecto =1. Esto genera que la ejecucion sea "aislada" o separada de la terminal central (que trabaja po defecto con overwrite_a=False), haciandola mas rapida. En este caso en particular se observa que es la alternativa mas rapida ya que en primer lugar esta trabajando la matriz laplaciana como simetrica positiva, y ademas se esta ejecitando de manera asilada volviendola claramente la opcion mas veloz en ejecucion.
