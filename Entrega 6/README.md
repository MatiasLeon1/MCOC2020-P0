
# Analisis Desempeño

### Grafico
![Desempeño Entrega 6](https://user-images.githubusercontent.com/43649125/90345901-a2861f80-dff2-11ea-94fc-07226e50ea0d.png)

* Podemos observar que el metodo de solucion Ainv_X_B es el más lento. Esto era de esperarse, ya que este método se realiza en 2 pasos. En primer lugar se invierte la matriz A y luego en otra variable se define la multiplicación entre A y B.
El resto de los métodos son de una sola ejecución. Podemos ver que a medida que N sube de valor tanto np.solve como scipy.solve se comportan de manera similar. Dado que estos solver son considerados "básicos" dentro de las funcionalidades que nos entregan numpy y scipy, no es extraño observar cierta similitud. Sin embargo y como se demostró en las entregas anteriores, scipy tiene un mejor desempeño comparado con numpy (en este gráfico se puede observar claramente cuando N es pequeño).
Lo interesante surge de los 3 solvers restantes. Scipy.solve Symmetric tiene la particularidad que define una de las matrices a multiplicar como simétrica, es decir que su matriz triangular inferior y superior son iguales. La manera en la que trabaja es que solo toma la diagonal y la matriz triangular superior para realizar la multiplicación y después replica los resultados en la matriz triangular inferior, esto evidentemente y como se aprecia en el gráfico la vuelve una alternativa más rápida que las mencionadas anteriormente. Cabe destacar que si uno no posee una matriz simétrica, la multiplicación se podrá realizar de igual manera,pero por que asumirá simetría y trabajara como se mencionó hace un instante, lo que implica que el resultado no será el real ya que no estará considerando los valores reales de la matriz triangular inferior.
El solver scipy.solve positive (pos) asume que la matriz indicada será simétrica y positiva. De esta manera se concentrará solo en los operadores positivos. Dado que en este caso particular nuestra matriz laplaciana tiene -1 a cada lado de la diagonal, estos valores no se consideran en el cálculo y aumenta la eficiencia en su cálculo (en parte porque los componentes restantes de la matriz son puros 0 y 2). Para el caso del soler scipy.solve positive overwrite hay que entender cuál es la funcionalidad del comando overwrite.
Cuando una operación de nuestro nivel se lleva a cabo en python, generalmente se trabaja con una función C-Fortran. Esta es una interfaz que relaciona las variables y las llamadas en subrutinas, ve la compatibilidad de los datos trabajados, el orden de las variables y la memoria utilizada, entre otros. Como interfaz de preferencia, su funcionalidad puede alterar los datos trabajados ya que su uso guarda archivos de memorias a medida que se ejecuta. Al utilizar el comando overwrite_a=True se está creando un argumento opcional con valor por defecto =1. Esto genera que la ejecución sea "aislada" o separada de la terminal central (que trabaja por defecto con overwrite_a=False), haciéndola más rápida. En este caso en particular se observa que es la alternativa más rápida ya que en primer lugar está trabajando la matriz laplaciana como simétrica positiva, y además se está ejecutando de manera aislada volviéndola claramente la opción más veloz en ejecución.

